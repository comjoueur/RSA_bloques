#include "Cifrado.h"
rsa::rsa(){
	ZZ p1=Generador_primo(512);
	ZZ p2=Generador_primo(512);
	n=p1*p2;
	ZZ f=(p1-1)*(p2-1);
	e=Generador_public(f);
	d=Inversa_mod(e,f);
	t=ZZ_str(n).size();
}
rsa::rsa(string p){
	if(p=="predefinido"|| p=="Predefinido"){
		string s1="16578997980679414594219599126094682869792894204559884549054206271530732326548211667927263164624402990615794505902511311413026172037113372511988172957109438895722767815551266637789681720372036846566384769955138170197279273072130245352711405333499316669297390390191815826198489208055921158866615799458010389109";
		string s2="35066434673590828221822968425639493315606814364980741419558268889386322666732832774682036632028502545417257010574498891195566517663072926030611604365191843022955723042558995753803033102942247561737686049398047306794774069596768437627845951351836101077351654578458515790898611623653666954250045000896347328989";
		string s3="75787514217952736476170763282341480739630939175818381325857419265618097339323435453679344315690846755748815569990867191001182322184138367320938932580377340064517538318113889420593594020004597080803264595022405645906353455498583376578236994092147894800185094015091839081186303394571567162914059153535891483609";
		d=str_ZZ(s1);
		e=str_ZZ(s2);
		n=str_ZZ(s3);
		t=308;
	}
	else{
		cout<<"Error en calculo de primos"<<endl;
	}
}
string rsa::cifrar (string p){
	vector<ZZ> vec=precifrado(p,diccionario,t);
	for(int i=0;i<vec.size();i++){
		vec[i]=Potencia_mod(vec[i],e,n);
	}
	return postcifrado(vec,t);
}
string rsa::descifrar (string p){
	vector<ZZ> vec=predescifrado(p,t);
	for(int i=0;i<vec.size();i++){
		vec[i]=Potencia_mod(vec[i],d,n);
	}
	return postdescifrado(vec,diccionario,t);
}
